<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.4 at 2016-06-14 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>valuelistservice - About</title>
<style type="text/css" media="all">
@import url("./css/maven-base.css");

@import url("./css/maven-theme.css");

@import url("./css/site.css");
</style>
<link rel="stylesheet" href="./css/print.css" type="text/css"
	media="print" />
<meta name="Date-Revision-yyyymmdd" content="20160614" />
<meta http-equiv="Content-Language" content="en" />

</head>
<body class="composite">
	<div id="banner">
		<div id="bannerLeft">valuelistservice</div>
		<div class="clear">
			<hr />
		</div>
	</div>
	<div id="breadcrumbs">


		<div class="xleft">
			<span id="publishDate">Last Published: 2016-06-14</span> &nbsp;| <span
				id="projectVersion">Version: 0.0.1-SNAPSHOT</span>
		</div>
		<div class="xright">
			<a href="./" title="valuelistservice">valuelistservice</a>


		</div>
		<div class="clear">
			<hr />
		</div>
	</div>
	<div id="leftColumn">
		<div id="navcolumn">


			<h5>Project Documentation</h5>
			<ul>
				<li class="expanded"><a href="project-info.html"
					title="Project Information">Project Information</a>
					<ul>
						<li class="none"><a href="dependencies.html"
							title="Dependencies">Dependencies</a></li>
						<li class="none"><a href="dependency-convergence.html"
							title="Dependency Convergence">Dependency Convergence</a></li>
						<li class="none"><a href="dependency-info.html"
							title="Dependency Information">Dependency Information</a></li>
						<li class="none"><strong>About</strong></li>
						<li class="none"><a href="plugin-management.html"
							title="Plugin Management">Plugin Management</a></li>
						<li class="none"><a href="plugins.html" title="Plugins">Plugins</a>
						</li>
						<li class="none"><a href="project-summary.html"
							title="Summary">Summary</a></li>
					</ul></li>
				<li class="collapsed"><a href="project-reports.html"
					title="Project Reports">Project Reports</a></li>
			</ul>
			<a href="http://maven.apache.org/" title="Built by Maven"
				class="poweredBy"> <img class="poweredBy" alt="Built by Maven"
				src="./images/logos/maven-feather.png" />
			</a>


		</div>
	</div>
	<div id="bodyColumn">
		<div id="contentBox">
			<div class="section">
				<h2>
					About valuelistservice<a name="About_valuelistservice"></a>
				</h2>
				<a name="About_valuelistservice"></a>
				<p>
					<p>
						<h1><strong>Project Overview</strong></h1>
					</p>
					<p>The idea of ValueListService is simple.</p>
					<ol>
						<li>Configure in XML SQL queries to run.</li>
						<li>Send HTTP request and get query results in JSON.</li>
					</ol>
					<p>
						The <em>valuelistservice.jar</em> provides a flexible framework to
						support queries to filter, sort, and page through large result
						sets.
					</p>
					<p>
						The full project is available at: 
						<a href="https://github.com/ryanp102694/valuelistservice">https://github.com/ryanp102694/valuelistservice</a>
					</p>
					<p>
						Docs can be found here:
						<a href="http://ryanp102694.github.io/valuelistservice/apidocs/index.html">ValueListService Documentation</a>
					</p>
					<p>
						<h1><strong>Interface Overview</strong></h1>
					</p>
					<p>
						The <strong>ValueListService</strong> interface is very simple, it
						contains one method to get back a <strong>Values</strong> object
						which holds results.
					</p>
					<div class="code">
						<img src="images/valuelistservice_interface.jpg" alt="ValueListService Interface"/>
					</div>
					<p>The intention of these parameters is the following.</p>
					<ol>
						<li><strong>key:</strong> Used to identify a query which the
							ValueListService is capable of running.</li>
						<li><strong>queryParams: </strong>Parameters used to by the
							query specified by</li>
						<li><strong>pagingInfo: </strong>An object which encapsulates
							requested page, and number of items per page for specified query.
							(This can be left null if paging is not necessary)</li>
					</ol>
					<p>
						The method returns <strong>Values&lt;? extends Object&gt;</strong>.
						Let&rsquo;s break that down.
					</p>
					<div class="code">
						<img src="images/values.jpg" alt="Values"/>
					</div>
					<p>As you can see, a Values is nothing more than a List and
						paging information, which tells the client the total number of
						items, page, and items per page. &nbsp;</p>
					<p>
						<h1><strong>Using Default Implementations</strong></h1>
					</p>
					<p>
						The <strong>DefaultValuesListService&lt;T&gt; </strong>is a simple
						implementation of <strong>ValueListService</strong>. The default
						service takes advantage of another interface, <strong>DataAdapter&lt;T&gt;</strong>.
						Essentially the default service has a map of adapters, which are
						accessible by the query key mentioned earlier. The adapters are
						actually what run the queries, and return the appropriate type
						from the service.
					</p>
					<p>
						Let&rsquo;s take a look at <strong>DataAdapter&lt;T&gt;.</strong>
					</p>
					<div class="code">
						<img src="images/dataadapter.jpg" alt="DataAdapter Interface"/>
					</div>				
					<p>
						Here we can see that the adapter returns the same type as the
						service does, in fact, the method is almost exactly the same as
						the service method, except that the <strong>key </strong>parameter
						is removed.
					</p>
					<p>
						The intention of a <strong>DataAdapter&lt;T&gt; </strong>implementation
						is to be able to allow different queries to return different
						types, as well as different queries to connect to different data
						sources. For example, we could have a <em>FileSystemDataAdapter</em>,
						<em>JdbcDataAdapter</em>, or even <em>MongoDBDataAdapter</em>.
					</p>
					<p>
						In fact, valueslistservice.jar includes a JDBC adapter, <strong>DefaultJdbcDataAdapter</strong>.
						Let&rsquo;s see how we can easily configure this in Spring to read
						data from a MySQL database.
					</p>
					<ol>
						<li><strong>Configure a DataSource and
								NamedParameterJdbcTemplate.</strong></li>
					</ol>
					<p>It is important to use NamedParameterJdbcTemplate for
						reasons we will see later.</p>
						<img src="images/datasource_config.jpg" alt="DataSource Config"/>						
					<ol start="2">
						<li><strong>Configure DefaultJdbcAdapter</strong></li>
					</ol>
					<p>Here I will be querying a sample MySQL table for employee
						department names.</p>
						<img src="images/jdbcadapter_config.jpg" alt="DefaultJdbcAdapter Config"/>						
					<ol start="3">
						<li><strong>Call standalone adapter.</strong></li>
					</ol>
					<p>
						You can use adapters apart from the service if you wish, in the
						following example program, we see our adapter query method
						producing the expected results. By default the results are of the
						type List&lt;Map&lt;String,Object&gt;&gt; due to Spring&rsquo;s <strong>ColumnMapRowMapper</strong>.
						Optionally, a <strong>RowMapper</strong>&lt;T&gt; can be injected
						into the adapter to return a different type.
					</p>
						<img src="images/example_main.jpg" alt="ValueListService Interface"/>					
					<p>&nbsp;</p>
					<p>&nbsp;</p>
					<p>&nbsp;</p>
					<ol start="4">
						<li><strong>Inject adapter into default
								ValueListService.</strong></li>
					</ol>
					<p>
						Ultimately, we will want to use the service, rather than the
						standalone adapter. The <strong>DefaultValueListService </strong>can
						be configured with the following XML.
					</p>
						<img src="images/valuelistservice_config.jpg" alt="ValueListService Interface"/>					
					<p>Additional adapters can be injected into the map, which are
						able to be accessed by key in the actual service.</p>
					<p>&nbsp;</p>
					<p>
						<strong>Paging</strong>
					</p>
					<p>
						Some result sets will be extremely large. The user may want only
						the first 1000 results, but they likely want to know the total
						number of results that match their query. By passing a <strong>PagingInfo
						</strong>object to our service, the adapter will correctly paginate our
						query. Since we are using MySQL, we inject <strong>MySQLPagingSupport
						</strong>into our adapter. When finished, the adapter configuration will
						look like this:
					</p>
					<img src="images/paging_config.jpg" alt="ValueListService Interface"/>					
					<p>
						Now, we can create a <strong>PagingInfo </strong>object, set the <em>numberPerPage</em>
						property, and the <em>page</em> property, and pass it to the
						service. The result will only show the correct information for the
						selected page.
					</p>
					<p>
						<strong>Complex Queries</strong>
					</p>
					<p>
						By default, the <strong>DefaultJdbcDataAdapter </strong>will use a
						<strong>VelocityQueryParameterMapper </strong>to pre-process any
						of the SQL that is run by Spring on the database. This allows the
						user to write the SQL as a velocity template, knowing that
						Velocity will attempt to map the parameters to the SQL.
					</p>
					<p>
						Let&rsquo;s write a query that takes advantage of velocity, as
						well as the <strong>NamedParameterJdbcTemplate</strong>.						
					</p>
					<img src="images/velocity_config.jpg" alt="ValueListService Interface"/>					
					<p>&nbsp;</p>
					<p>&nbsp;</p>
					<p>&nbsp;</p>
					<p>Suppose we pass in a map with our parameters which includes
						(&ldquo;dept_name&rdquo;, &ldquo;Customer Service&rdquo;).</p>
					<p>Two things will happen before the SQL is actually run.</p>
					<ol>
						<li>Velocity will process the SQL, transforming it into:</li>
					</ol>
					<p>
						<em>SELECT * FROM employees.departments WHERE dept_name =
							:dept_name</em>
					</p>
					<ol start="2">
						<li>The Spring template will insert the value of the
							parameter in place of &lt;:dept_name&gt; The final query becomes:</li>
					</ol>
					<p>
						<em>SELECT * FROM employees.departments WHERE dept_name =
							&ldquo;Customer Service&rdquo;</em>
					</p>
					<p>
						<strong>Using Velocity templating allows the defined
							queries to be flexible and allow filtering and sorting based on
							the existence of certain parameters.</strong>
					</p>
					<p>
						<strong>Further Extension</strong>
					</p>
					<p>
						If necessary, classes can be written which build upon the existing
						interfaces. For example, if a user wishes to not use Velocity
						templating. They could create a class which implements <strong>QueryParameterMapper</strong>,
						and inject that into the adapter. Or suppose Microsoft SQL Server
						is being used. It may be necessary to implement the <strong>SQLPagingSupport
						</strong>interface to support paging.
					</p>
					<p>&nbsp;</p>
					<p>
						<h1><strong>Using ValueListService in a Web Service</strong></h1>
					</p>
					<p>The original purpose of this project was to get JSON
						results. An example of this being done is in a Spring MVC project
						with Jackson JSON processing.</p>
					<p>
						An example service can be found here: <a
							href="https://github.com/ryanp102694/valuelistservice_webservice">https://github.com/ryanp102694/valuelistservice_webservice</a>
					</p>
					<p>
						Let&rsquo;s take a look at our <strong>ValueListServiceController</strong>,
						which is really the only code in the project.
					</p>
					<p>&nbsp;</p>
					<p>Basically, this is what is going on here.</p>
					<ol>
						<li>The <strong>ValueListService</strong> is injected into
							the controller using the @Autowired annotation. The service is
							defined in a Spring xml file.
						</li>
						<li>Parameters are taken from the request and put into a
							parameter map.</li>
						<li>A <strong>PagingInfo </strong>object is constructed from
							specific parameters <em>page </em>and <em>numberPerPage</em>.
						</li>
						<li><strong>ValueListService </strong>is called, getting the
							Values. The Values are then marshalled to JSON by the Jackson
							library, before being sent in the response body.</li>
					</ol>
					<p>
						When using <strong>ValueListService </strong>in a web service, a
						problem arises. <strong>Query parameters in an
							HttpServletRequest are Strings! </strong>What does this mean when we need
						to pass a date in a format like &ldquo;1994-10-27&rdquo;? After
						all, Spring needs a java.util.Date to run the correct SQL query.
					</p>
					<p>
						<strong>Configuring the AdapterConversionService</strong>
					</p>
					<p>
						The <strong>DefaultJdbcDataAdapter </strong>has a property <strong>AdapterConversionService</strong>.
						When configured, the adapter will convert parameters from one type
						to another, based on the adapter requirements.
					</p>
					<img src="images/adapterconversion_interface.jpg" alt="ValueListService Interface"/>					
					<p>&nbsp;</p>
					<p>
						&nbsp;By default, the adapter uses <strong>ParameterConversionService</strong>,
						which extends Spring <strong>DefaultConversionService</strong>. <strong>ParameterConversionService
						</strong>has a Map&lt;String,Class&gt;, as well as a list of <strong>Converter</strong>
						objects. When the <strong>ParameterConversionService </strong>calls
						its implemented method, it checks to see if the name of the
						parameter is in its map, if it is, it will use a <strong>Converter</strong>
						from its registry to attempt to convert the parameter value to the
						target class type.
					</p>
					<p>&nbsp;</p>
					<p>&nbsp;</p>
					<p>
						Let&rsquo;s see an example of how to configure this. Here is the
						configuration for a <strong>ParameterConversionService </strong>bean.
					</p>
					<img src="images/adapterconversion_config.jpg" alt="Adapter Conversion Config"/>					
					<p>
						Here we can see that we have set up query parameter maps with keys
						&ldquo;birth_date&rdquo; or &ldquo;hire_date&rdquo; to have their
						values converted to java.util.Date. We have also implemented
						Spring&rsquo;s <strong>Converter&lt;S,T&gt; </strong>interface in
						the <strong>DefaultStringToDateConverter </strong>class. This
						converter is then added to the conversion service&rsquo;s list of
						converters. This bean will be injected into the adapter&rsquo;s
						adapterConversionService property.
					</p>
					<p>
						<strong>Note:</strong> Spring&rsquo;s MapFactoryBean and
						ListFactoryBean can be set up as parent-child beans, so that their
						lists and maps inherit values. This is useful if a global type
						conversion map or converters list must be configured.
					</p>
					<p>Our adapter can now convert parameters from one type to
						another in order to run its query.</p>


				</p>
			</div>
		</div>
	</div>
	<div class="clear">
		<hr />
	</div>
	<div id="footer">
		<div class="xright">Copyright &#169; 2016. All Rights Reserved.

		</div>
		<div class="clear">
			<hr />
		</div>
	</div>
</body>
</html>
