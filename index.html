<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.4 at 2016-06-14 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>ValueListService - About</title>
<style type="text/css" media="all">
@import url("./css/maven-base.css");
@import url("./css/maven-theme.css");
@import url("./css/site.css");
</style>
<link rel="stylesheet" href="./css/print.css" type="text/css"media="print" />
<meta name="Date-Revision-yyyymmdd" content="20160614" />
<meta http-equiv="Content-Language" content="en" />

</head>
<body class="composite">
	<div id="banner">
		<div id="bannerLeft">valuelistservice</div>
		<div class="clear">
			<hr />
		</div>
	</div>
	<div id="breadcrumbs">


		<div class="xleft">
			<span id="publishDate">Last Published: 2016-06-14</span> &nbsp;| <span
				id="projectVersion">Version: 0.0.1-SNAPSHOT</span>
		</div>
		<div class="xright">
			<a href="./" title="valuelistservice">valuelistservice</a>


		</div>
		<div class="clear">
			<hr />
		</div>
	</div>
	<div id="leftColumn">
		<div id="navcolumn">


			<h5>Project Documentation</h5>
			<ul>
				<li class="expanded"><a href="project-info.html"
					title="Project Information">Project Information</a>
					<ul>
						<li class="none"><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
						<li class="none"><a href="dependency-convergence.html" title="Dependency Convergence">Dependency Convergence</a></li>
						<li class="none"><a href="dependency-info.html" title="Dependency Information">Dependency Information</a></li>
						<li class="none"><strong>About</strong></li>
						<li class="none"><a href="plugin-management.html" title="Plugin Management">Plugin Management</a></li>
						<li class="none"><a href="plugins.html" title="Plugins">Plugins</a></li>
						<li class="none"><a href="project-summary.html" title="Summary">Summary</a></li>
					</ul>
				</li>
				<li class="collapsed"><a href="project-reports.html" title="Project Reports">Project Reports</a></li>
			</ul>
			<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"> <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>


		</div>
	</div>
	<div id="bodyColumn">
		<div id="contentBox">
			<div class="section">
				<h2>
					Getting Started with ValueListService<a name="About_valuelistservice"></a>
				</h2>
				<a name="About_valuelistservice"></a>
				<p>
					<p>
						<h1><strong>Project Overview|<a href="http://ryanp102694.github.io/valuelistservice/apidocs/index.html">JavaDocs</a>|<a href="https://github.com/ryanp102694/valuelistservice">Code</a></strong></h1>
					</p>
					<p>The idea of ValueListService is simple.</p>
					<ol>
						<li>Configure in XML SQL queries to run.</li>
						<li>Send HTTP request and get query results in JSON.</li>
					</ol>
					<p>
						The <em>valuelistservice.jar</em> provides a flexible framework to
						support queries to filter, sort, and page through large result
						sets.
					</p>
					<p>
						<h1><strong>Interface Overview</strong></h1>
					</p>
					<p>
						The <strong>ValueListService</strong> interface is very simple, it
						contains one method to get back a <strong>Values</strong> object
						which holds results.
					</p>
					<div class="code">
						<img src="images/valuelistservice_interface.jpg" alt="ValueListService Interface" style="height:80px;"/>
					</div>
					<p>The intention of these parameters is the following.</p>
					<ol>
						<li><strong>key:</strong> Used to identify a query which the
							ValueListService is capable of running.</li>
						<li><strong>queryParams: </strong>Parameters used to by the
							query specified by</li>
						<li><strong>pagingInfo: </strong>An object which encapsulates
							requested page, and number of items per page for specified query.
							(This can be left null if paging is not necessary)</li>
					</ol>
					<p>
						The method returns <strong>Values&lt;? extends Object&gt;</strong>.
						Let&rsquo;s break that down.
					</p>
					<div class="code">
						<img src="images/values.jpg" alt="Values"/>
					</div>
					<p>As you can see, a Values is nothing more than a List and
						paging information, which tells the client the total number of
						items, page, and items per page. &nbsp;</p>
					<p>
						<h1><strong>Using Default Implementations</strong></h1>
					</p>
					<p>
						The <strong>DefaultValuesListService&lt;T&gt; </strong>is a simple
						implementation of <strong>ValueListService</strong>. The default
						service takes advantage of another interface, <strong>DataAdapter&lt;T&gt;</strong>.
						Essentially the default service has a map of adapters, which are
						accessible by the query key mentioned earlier. The adapters are
						actually what run the queries, and return the appropriate type
						from the service.
					</p>
					<p>
						Let&rsquo;s take a look at <strong>DataAdapter&lt;T&gt;.</strong>
					</p>
					<div class="code">
						<img src="images/dataadapter.jpg" alt="DataAdapter Interface"/>
					</div>				
					<p>
						Here we can see that the adapter returns the same type as the
						service does, in fact, the method is almost exactly the same as
						the service method, except that the <strong>key </strong>parameter
						is removed.
					</p>
					<p>
						The intention of a <strong>DataAdapter&lt;T&gt; </strong>implementation
						is to be able to allow different queries to return different
						types, as well as different queries to connect to different data
						sources. For example, we could have a <em>FileSystemDataAdapter</em>,
						<em>JdbcDataAdapter</em>, or even <em>MongoDBDataAdapter</em>.
					</p>
					<p>
						In fact, valueslistservice.jar includes a JDBC adapter, <strong>DefaultJdbcDataAdapter</strong>.
						Let&rsquo;s see how we can easily configure this in Spring to read
						data from a MySQL database.
					</p>
					<h3><strong>1. Configure a DataSource</strong></h3>
						<div class="code">
							<img src="images/datasource_config.jpg" alt="DataSource Config"/>
						</div>						
					<h3><strong>2. Configure DefaultJdbcAdapter</strong></h3>
					<p>Here I will be querying a sample MySQL table for employee
						department names.</p>
						<div class="code">
							<img src="images/jdbcadapter_config.jpg" alt="DefaultJdbcAdapter Config" style="height: 150px;"/>
						</div>					
					<h3><strong>3. Call standalone adapter</strong></h3>
					<p>
						You can use adapters apart from the service if you wish, in the
						following example program, we see our adapter query method
						producing the expected results. By default the results are of the
						type List&lt;Map&lt;String,Object&gt;&gt; due to Spring&rsquo;s <strong>ColumnMapRowMapper</strong>.
						Optionally, a <strong>RowMapper</strong>&lt;T&gt; can be injected
						into the adapter to return a different type.
					</p>
					<div class="code">
						<img src="images/example_main.jpg" alt="ValueListService Interface" style="height: 200px;"/>
					</div>					
					<p>&nbsp;</p>
					<h3><strong>4. Inject adapter into default ValueListService</strong></h3>
					<p>
						Ultimately, we will want to use the service, rather than the
						standalone adapter. The <strong>DefaultValueListService </strong>can
						be configured with the following XML. Like the example Main class above, we can
						get our valueListService bean, and call getValuesList to get our results.
					</p>
					<div class="code">
						<img src="images/valuelistservice_config.jpg" alt="ValueListService Interface"/>
					</div>					
					<p>Additional adapters can be injected into the map, which are
						able to be accessed by key in the actual service.</p>
					<p>&nbsp;</p>
					<p>
						<h3><strong>Paging</strong></h3>
					</p>
					<p>
						Some result sets will be extremely large. The user may want only
						the first 1000 results, but they likely want to know the total
						number of results that match their query. By passing a <strong>PagingInfo
						</strong>object to our service, the adapter will correctly paginate our
						query. Since we are using MySQL, we inject <strong>MySQLPagingSupport
						</strong>into our adapter. When finished, the adapter configuration will
						look like this:
					</p>
					<div class="code">
						<img src="images/paging_config.jpg" alt="ValueListService Interface" style="height:150px;"/>
					</div>				
					<p>
						Now, we can create a <strong>PagingInfo </strong>object, set the <em>numberPerPage</em>
						property, and the <em>page</em> property, and pass it to the
						service. The result will only show the correct information for the
						selected page.
					</p>
					<p>
						<h3><strong>Complex Queries</strong></h3>
					</p>
					<p>
						By default, the <strong>DefaultJdbcDataAdapter </strong>will use a
						<strong>VelocityQueryParameterMapper </strong>to pre-process any
						of the SQL that is run by Spring on the database. This allows the
						user to write the SQL as a velocity template, knowing that
						Velocity will attempt to map the parameters to the SQL.
					</p>
					<p>
						Let&rsquo;s write a query that takes advantage of velocity, as
						well as the <strong>NamedParameterJdbcTemplate</strong>.						
					</p>
					<div class="code">
						<img src="images/velocity_config.jpg" alt="ValueListService Interface" style="height:60px;"/>
					</div>					
					<p>&nbsp;</p>
					<p>Suppose we pass in a map with our parameters which includes
						(&ldquo;dept_name&rdquo;, &ldquo;Customer Service&rdquo;).</p>
					<p>Two things will happen before the SQL is actually run.</p>
					<ol>
						<li>Velocity will process the SQL, transforming it into: <strong><code>SELECT * FROM employees.departments WHERE dept_name = :dept_name</code></strong></li>
					</ol>
					
					<ol start="2">
						<li>The Spring template will insert the value of the parameter in place of &lt;:dept_name&gt; The final query becomes:<code><strong>SELECT * FROM employees.departments WHERE dept_name = &ldquo;Customer Service&rdquo;</code></strong></li>
					</ol>
					<p>
						<strong>Using Velocity templating allows the defined
							queries to be flexible and allow filtering and sorting based on
							the existence of certain parameters.</strong>
					</p>
				</p>
				<h3><strong>Configuring the AdapterConversionService</strong></h3>
				<p>
					When using <strong>ValueListService </strong>in a web service, a
					problem arises. <strong>Query parameters in an
					HttpServletRequest are Strings! </strong>What does this mean when we need
					to pass a date in a format like &ldquo;1994-10-27&rdquo;? After
					all, Spring needs a java.util.Date to run the correct SQL query.
				</p>
				<p>
					The <strong>DefaultJdbcDataAdapter </strong>has a property <strong>AdapterConversionService</strong>.
					When configured, the adapter will convert parameters from one type
					to another, based on the adapter requirements.
				</p>
				<div class="code">
					<img src="images/adapterconversion_interface.jpg" alt="ValueListService Interface" style="height: 75px"/>
				</div>
				<p>&nbsp;</p>
				<p>
					&nbsp;By default, the adapter uses <strong>ParameterConversionService</strong>,
					which extends Spring <strong>DefaultConversionService</strong>. <strong>ParameterConversionService
				</strong>has a Map&lt;String,Class&gt;, as well as a list of <strong>Converter</strong>
					objects. When the <strong>ParameterConversionService </strong>calls
					its implemented method, it checks to see if the name of the
					parameter is in its map, if it is, it will use a <strong>Converter</strong>
					from its registry to attempt to convert the parameter value to the
					target class type.
				</p>
				<p>
					<strong>NOTE: </strong> ParameterConversionService will throw unchecked exceptions if 
					there is a conversion error, we will talk about this later.
				</p>
				<p>&nbsp;</p>
				<p>
					Let&rsquo;s see an example of how to configure this. Here is the
					configuration for a <strong>ParameterConversionService </strong>bean.
				</p>
				<div class="code">
					<img src="images/adapterconversion_config.jpg" alt="Adapter Conversion Config" style="height:375px;"/>
				</div>
				<p>
					Here we can see that we have set up query parameter maps with keys
					&ldquo;birth_date&rdquo; or &ldquo;hire_date&rdquo; to have their
					values converted to java.util.Date. We have also implemented
					Spring&rsquo;s <strong>Converter&lt;S,T&gt; </strong>interface in
					the <strong>DefaultStringToDateConverter </strong>class. This
					converter is then added to the conversion service&rsquo;s list of
					converters. This bean will be injected into the adapter&rsquo;s
					adapterConversionService property.
				</p>
				<p>
					<strong>Note:</strong> Spring&rsquo;s MapFactoryBean and
					ListFactoryBean can be set up as parent-child beans, so that their
					lists and maps inherit values. This is useful if a global type
					conversion map or converters list must be configured.
				</p>
				<p>Our adapter can now convert parameters from one type to another in order to run its query.</p>
					<p>
						<h3><strong>Further Extension</strong></h3>
					</p>
					<p>
						If necessary, classes can be written which build upon the existing
						interfaces. For example, if a user wishes to not use Velocity
						templating. They could create a class which implements <strong>QueryParameterMapper</strong>,
						and inject that into the adapter. Or suppose Microsoft SQL Server
						is being used. It may be necessary to implement the <strong>SQLPagingSupport
						</strong>interface to support paging.
					</p>
					<p>
						The user could also choose to create their own DataAdapters, and wire them into their service.
					</p>
					<p>&nbsp;</p>
					<p>
						<h1><strong>Using ValueListService in a Spring MVC Project</strong></h1>
					</p>
					<p>The original purpose of this project was to get JSON
						results. An example of this being done is in a <a href="https://github.com/ryanp102694/valuelistservice_webservice/commits?author=ryanp102694">Spring MVC</a> project
						with Jackson JSON processing.
					</p>
					<p>
						Let&rsquo;s take a look at our <strong>ValueListServiceController</strong>,
						which is in the <strong>valuelistservice.jar</strong>.
					</p>
					<div class="code">
						<img src="images/valuelistservice_controller.jpg" alt="ValueListServiceController" style="height:325px;"/>
					</div>
					<p>&nbsp;</p>
					<p>Basically, this is what is going on here.</p>
					<ol>
						<li>The <strong>ValueListService</strong> is injected into
							the controller using the @Autowired annotation. The service is
							defined in a Spring xml file.
						</li>
						<li>Parameters are taken from the request and put into a
							parameter map.
						</li>
						<li>A <strong>PagingInfo </strong>object is constructed from
							specific parameters <em>page </em>and <em>numberPerPage</em>.
						</li>
						<li><strong>ValueListService </strong>is called, getting the
							Values. The Values are then marshalled to JSON by the Jackson
							library, before being sent in the response body.
						</li>
					</ol>
				<p>
					In order for this to work, the jar must be put in a Spring project which uses the component-scan and annotation-driven xml.
					Note that one of the base-packages being scanned must be com.pelletier, which is the package for the controller.
				</p>
				<p>
					&lt;context:component-scan base-package="com.pelletier"/&gt;<br>
					&lt;mvc:annotation-driven/&gt;
				</p>
				<p>
					<strong>NOTE: </strong> Query parameter "valueListQuery" is necessary to select a query from 
					the configured map of queries in <strong>DefaultValueListService</strong>. Also in order for paging to work,
					parameters "page" and "numberPerPage" are required.
				</p>
				<h3><strong>Calling the Web Service</strong></h3>
				<p>
					A simple curl command can call the webservice. An example of this would be the following.
				</p>
				<p>
					<code>
					curl -X GET -H "Cache-Control: no-cache" "http://localhost:8080/valueslistservice/values?valueListQuery=query&page=1&numberPerPage=10"
					</code>
				</p>
				<p>
					The response should be whatever Java objects the service returns, serialized into JSON.
				</p>
				<h3><strong>Handling Errors</strong></h3>
				<p>
					Before, we mentioned how the <strong>ParameterConversionService</strong> can throw runtime exceptions.
					The <strong>ParameterConversionService</strong> specifically will throw <strong>ConversionException</strong>.
					What happens when one of these exceptions is thrown? What happens if a different type of exception is thrown,
					for example, some sort of SQL exception?
				</p>
				<p>
					The following exception handlers will catch any exceptions thrown from within the controller.
				</p>
				<div class="code">
					<img src="images/exception_handlers.JPG" alt="Exception Handlers" style="height:225px;"/>
				</div>
				<p>
					Here, you can see there are two exception handlers. Both of these return <strong>ErrorInfo</strong> objects. 
					These contain more user friendly messages that are nice to display on the front-end, but also wrap the
					Exception. These ErrorInfo objects are also serialized into JSON.
				</p>
				<p>
					Note that the top handler returns a <strong>List&lt;ErrorInfo&gt;</strong>, this is because this
					handler specifically maps to <strong>ConvertionExceptions</strong> which wrap multiple exceptions.
					The reason for this is because, if multiple exceptions are thrown in conversions, the client needs to know all of the
					conversion errors. The bottom handler will catch any other exceptions that are thrown in the controller. 				
				</p>
			</div>
		</div>
	</div>
	<div class="clear">
		<hr />
	</div>
	<div id="footer">
		<div class="xright">Copyright &#169; 2016. All Rights Reserved.

		</div>
		<div class="clear">
			<hr />
		</div>
	</div>
</body>
</html>
